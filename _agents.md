# Follow idiomatic Terraform module structure  

## Context

## Decision

We recommend to follow idiomatic Terraform module structure:

ðŸ“‚ Inside a reusable Terraform module
- `main.tf` â†’ Core resources and data sources (the logic of the module).
- `variables.tf` â†’ Input variables with types, descriptions, and defaults.
- `outputs.tf` â†’ Output values that the root module can consume.
- `versions.tf` â†’ The terraform {} block with:
    - required_version (Terraform version constraint).
    - required_providers (provider version constraints).
- `providers.tf` (optional) â†’ Sometimes used to declare provider configurations if the module needs multiple providers (but usually provider config comes from the root, not the module).
- `locals.tf` (optional) â†’ Local variables for intermediate values or computed expressions.
- `data.tf` (optional) â†’ Data sources, if separated for clarity.
- `README.md` â†’ Documentation for how to use the module.
- `examples/` â†’ Example usage of the module (best practice for reusable, published modules).
- `tests/` â†’ Contains automated tests for the module. Typically, this includes integration tests written in Go using [Terratest](https://terratest.gruntwork.io/), which deploy the module in a real or test environment to verify its behavior. The folder may also include test fixtures, helper scripts, and configuration files needed to run the tests.

ðŸ“‚ In a root module (where you use the reusable modules)
- main.tf â†’ Instantiates modules and defines resources.
- providers.tf â†’ Provider configuration (region, credentials, etc.).
- versions.tf â†’ Terraform and provider constraints.
- variables.tf â†’ Input variables for the root configuration.
- outputs.tf â†’ Outputs exposed from the root.
- terraform.tfvars / *.auto.tfvars â†’ Values for variables (e.g., environment-specific).

## Consequences

- If this structure is not followed in the project, suggest to start doing so.


# Use Gruntwork-style Terraform structure (Infrastructure Live) in a per-service monorepo

## Context

We want all Terraform for a service in one place for:
- Simpler discovery, onboarding, and atomic changes across environments
- Clear separation between reusable modules and environment compositions
- Safe promotion (devâ†’stagingâ†’prod)

## Decision

Adopt a [Gruntwork-style "Infrastructure Live" layout](https://docs.gruntwork.io/2.0/docs/overview/concepts/infrastructure-live) inside a single repository:

```
live/                     # environment compositions (what we run)
  envs/
    dev/                  # You can include region subdirectories for non-global cloud providers like AWS. For example: /dev/eu-central-1/
    staging
    prod
  globals/                # Optional: environment-independent: some of IAMs, DNS, SCPs
  policies/               # Optional: OPA/Sentinel/Conftest
modules/                  # reusable versioned modules (how we build)
  networking/vpc/
  compute/ecs-service/
  data/rds/
tooling/                  # Optional: CI workflows, shared scripts, lint/policy configs
```

**Modules** are semver-tagged via git tags (e.g., `modules/networking/vpc@v1.4.2`) and **pinned** from `live/` using `?ref=<tag>`. It is fine to keep `modules/` directory without grouping for smaller deployments:

```
modules/
  vpc/
  ecs-service/
  rds/
```

Minimal example usage from `live`:

```hcl
module "vpc" {
  source = "git::ssh://git.example.com/infra.git//terraform/modules/networking/vpc?ref=v1.4.2"
  name   = "core-prod-euc1"
  cidr   = "10.20.0.0/16"
  tags   = local.standard_tags
}
```

## Consequences

**Positive**

* Single source of truth; easier cross-env changes and reviews.
* Clear separation of concerns (live vs. modules) within one repo.
* Whole IaC history is tracked within one git repository history
* Deterministic promotion via pinned module tags.
* Simplicity of discovery/onboarding.
* Repeatable promotion across environments.
* Minimize repo sprawl.

**Negative**

* Release choreography inside one repo (tag modules, then bump in live).
* Larger repo; requires discipline on boundaries and CI performance.

## Alternatives considered

* **Two-repo (live + modules):** cleaner ownership lines, but splits change history and adds coordination overhead. Overkill for Infrastructure Live per-service approach.

# Don't refactor terraform-docs generated documentation

If you see markdown documentation between `<!-- BEGIN_TF_DOCS -->` and `<!-- END_TF_DOCS -->`, it means that it was generated with [terraform-docs](https://github.com/terraform-docs/terraform-docs). Don't refactor it as such documentation is autogenerated and should be overriden by `terraform-docs` execution in CI environment. Refactoring autogenerated docs only generates extra review effort for person accepting your changes.  


# Apply `terraform fmt` after changing project

Apply `terraform fmt -recursive` if you touched any `*.tf` files in the project. I don't to do it manually after you or having my CI pipeline failed because of invalid whitespace formatting.  


# Apply `terraform validate` after changing project

Apply `terraform validate` if you touched any `*.tf` files (or any other relevant files) in the project. I don't to do it manually after you or having my CI pipeline failed because of validation errors.  